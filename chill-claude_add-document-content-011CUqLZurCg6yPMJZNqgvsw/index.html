<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MINOOTS - Distributed Horology Platform</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;600;700;800;900&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/ScrollTrigger.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --cyan: #00ffff;
            --magenta: #ff00ff;
            --blue: #0080ff;
            --green: #00ff80;
            --font-display: 'Orbitron', sans-serif;
            --font-body: 'Inter', system-ui, sans-serif;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000000;
        }

        body {
            font-family: var(--font-body);
            color: #ffffff;
            -webkit-font-smoothing: antialiased;
        }

        /* VIB3+ Quantum Visualizer - FIXED BACKGROUND */
        .quantum-layers {
            position: fixed;
            inset: 0;
            z-index: 0;
            pointer-events: none;
            transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.8s ease;
            will-change: transform, opacity;
            opacity: 1;
        }

        /* Visualizer responds to card interactions */
        .quantum-layers.enhanced {
            opacity: 0.8;
            filter: blur(2px) brightness(1.2);
        }

        .quantum-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            mix-blend-mode: screen;
            transition: opacity 0.5s ease;
        }

        #quantum-background {
            opacity: 0.35;
            z-index: 1;
            animation: pulseBackground 6s ease-in-out infinite;
        }
        #quantum-shadow {
            opacity: 0.25;
            z-index: 2;
            mix-blend-mode: multiply;
            animation: pulseBackground 7s ease-in-out infinite reverse;
        }
        #quantum-content {
            opacity: 0.65;
            z-index: 3;
            animation: pulseBackground 8s ease-in-out infinite;
        }
        #quantum-highlight {
            opacity: 0.45;
            z-index: 4;
            animation: pulseBackground 9s ease-in-out infinite reverse;
        }
        #quantum-accent {
            opacity: 0.3;
            z-index: 5;
            animation: pulseBackground 10s ease-in-out infinite;
        }

        @keyframes pulseBackground {
            0%, 100% { opacity: var(--base-opacity, 0.3); }
            50% { opacity: calc(var(--base-opacity, 0.3) * 1.3); }
        }

        /* CONTENT CONTAINER - ALWAYS CENTERED */
        #content-container {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .content-wrapper {
            max-width: 1200px;
            width: 100%;
            padding: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* CARD CHOREOGRAPHY SYSTEM */
        .card-stage {
            position: relative;
            width: 100%;
            max-width: 1200px;
            height: 600px;
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
            gap: 40px;
            perspective: 2000px;
            transform-style: preserve-3d;
        }

        .morph-card {
            position: relative;
            padding: 60px 50px;
            background:
                linear-gradient(135deg, rgba(10, 10, 30, 0.9) 0%, rgba(20, 10, 40, 0.85) 100%);
            backdrop-filter: blur(30px) saturate(180%);
            -webkit-backdrop-filter: blur(30px) saturate(180%);
            border: 2px solid transparent;
            background-clip: padding-box;
            box-shadow:
                0 0 80px rgba(0, 255, 255, 0.25),
                0 0 40px rgba(255, 0, 255, 0.15),
                inset 0 0 60px rgba(0, 255, 255, 0.08),
                inset 0 0 30px rgba(255, 0, 255, 0.05),
                0 20px 60px rgba(0, 0, 0, 0.5);
            transition: all 1.0s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform-style: preserve-3d;
            will-change: transform, opacity, border-radius;
            overflow: hidden;
        }

        /* Holographic border effect */
        .morph-card::before {
            content: '';
            position: absolute;
            inset: -2px;
            background: linear-gradient(
                135deg,
                rgba(0, 255, 255, 0.4) 0%,
                rgba(255, 0, 255, 0.4) 25%,
                rgba(0, 128, 255, 0.4) 50%,
                rgba(0, 255, 128, 0.4) 75%,
                rgba(0, 255, 255, 0.4) 100%
            );
            border-radius: inherit;
            z-index: -1;
            opacity: 0.3;
            filter: blur(8px);
            animation: holoBorder 8s ease-in-out infinite;
        }

        @keyframes holoBorder {
            0%, 100% {
                background-position: 0% 50%;
                filter: blur(8px) hue-rotate(0deg);
            }
            50% {
                background-position: 100% 50%;
                filter: blur(12px) hue-rotate(45deg);
            }
        }

        /* Prismatic reflection layer */
        .morph-card::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent 30%,
                rgba(0, 255, 255, 0.1) 45%,
                rgba(255, 0, 255, 0.15) 50%,
                rgba(0, 255, 255, 0.1) 55%,
                transparent 70%
            );
            transform: translateX(-100%);
            transition: transform 2s ease-out;
            pointer-events: none;
        }

        .morph-card.active::after {
            transform: translateX(100%);
        }

        .morph-card:hover {
            border-color: rgba(0, 255, 255, 0.6);
            box-shadow:
                0 0 120px rgba(0, 255, 255, 0.4),
                0 0 60px rgba(255, 0, 255, 0.25),
                inset 0 0 80px rgba(0, 255, 255, 0.12),
                inset 0 0 40px rgba(255, 0, 255, 0.08),
                0 30px 80px rgba(0, 0, 0, 0.6);
            transform: translateZ(20px) scale(1.02);
        }

        /* Card States for Splitting */
        .card-stage.split-2 {
            grid-template-columns: 1fr 1fr;
        }

        .card-stage.split-3 {
            grid-template-columns: repeat(3, 1fr);
        }

        .card-stage.split-4 {
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
        }

        .morph-card.card-clone {
            opacity: 0;
            transform: scale(0.8) rotateY(-20deg);
        }

        .morph-card.card-clone.active {
            opacity: 1;
            transform: scale(1) rotateY(0deg);
        }

        /* Card background accent - holographic layers */
        .card-bg-accent {
            position: absolute;
            inset: 0;
            background:
                radial-gradient(circle at var(--accent-x, 50%) var(--accent-y, 50%),
                    rgba(0, 255, 255, 0.15) 0%,
                    rgba(255, 0, 255, 0.08) 30%,
                    transparent 70%),
                radial-gradient(circle at calc(100% - var(--accent-x, 50%)) calc(100% - var(--accent-y, 50%)),
                    rgba(255, 0, 255, 0.12) 0%,
                    rgba(0, 255, 255, 0.06) 30%,
                    transparent 70%);
            opacity: 0;
            transition: opacity 0.8s ease;
            pointer-events: none;
            animation: accentPulse 6s ease-in-out infinite;
        }

        @keyframes accentPulse {
            0%, 100% { opacity: 0; filter: blur(40px); }
            50% { opacity: 1; filter: blur(60px); }
        }

        /* Depth layer for parallax effect */
        .card-depth-layer {
            position: absolute;
            inset: -10%;
            background: radial-gradient(ellipse at center,
                rgba(0, 255, 255, 0.05) 0%,
                transparent 60%);
            filter: blur(50px);
            opacity: 0.6;
            pointer-events: none;
            z-index: -2;
            animation: depthFloat 8s ease-in-out infinite;
        }

        @keyframes depthFloat {
            0%, 100% { transform: translateZ(-100px) scale(1.1); }
            50% { transform: translateZ(-150px) scale(1.15); }
        }

        /* TYPOGRAPHY */
        h1 {
            font-family: var(--font-display);
            font-size: clamp(3rem, 7vw, 6rem);
            font-weight: 900;
            line-height: 1.1;
            margin-bottom: 30px;
            background: linear-gradient(135deg,
                var(--cyan) 0%,
                var(--magenta) 50%,
                var(--blue) 100%);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            opacity: 0;
            transform: translateY(60px) scale(0.8);
            transition: all 1.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.4))
                    drop-shadow(0 0 40px rgba(255, 0, 255, 0.3));
            animation: gradientShift 8s ease-in-out infinite;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        h2 {
            font-family: var(--font-display);
            font-size: clamp(2.5rem, 5vw, 4.5rem);
            font-weight: 700;
            margin-bottom: 24px;
            color: var(--cyan);
            opacity: 0;
            transform: translateY(50px) scale(0.85);
            transition: all 1.1s cubic-bezier(0.34, 1.56, 0.64, 1) 0.1s;
            text-shadow:
                0 0 20px rgba(0, 255, 255, 0.6),
                0 0 40px rgba(0, 255, 255, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.5);
        }

        .subtitle {
            font-size: clamp(1.3rem, 2.5vw, 2rem);
            font-weight: 300;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 40px;
            opacity: 0;
            transform: translateY(40px) translateX(-20px);
            transition: all 1s cubic-bezier(0.34, 1.56, 0.64, 1) 0.2s;
        }

        .body-text {
            font-size: clamp(1.1rem, 1.8vw, 1.5rem);
            line-height: 1.9;
            color: rgba(255, 255, 255, 0.75);
            margin-bottom: 30px;
            opacity: 0;
            transform: translateY(30px) translateX(20px);
            transition: all 0.9s cubic-bezier(0.34, 1.56, 0.64, 1) 0.3s;
        }

        /* ACTIVE STATE - Show all elements */
        .active h1, .morph-card h1 {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .active h2, .morph-card h2 {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .active .subtitle, .morph-card .subtitle {
            opacity: 1;
            transform: translateY(0) translateX(0);
        }

        .active .body-text, .morph-card .body-text {
            opacity: 1;
            transform: translateY(0) translateX(0);
        }

        .active .card-bg-accent, .morph-card .card-bg-accent {
            opacity: 1;
        }

        /* Smooth text transitions */
        h1, h2, .subtitle, .body-text {
            will-change: opacity, transform;
        }

        /* STATS GRID */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 30px;
            margin-top: 50px;
        }

        .stat-card {
            padding: 30px;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.08) 0%, rgba(255, 0, 255, 0.05) 100%);
            border: 1px solid rgba(0, 255, 255, 0.25);
            border-radius: 20px;
            text-align: center;
            opacity: 0;
            transform: translateY(40px) rotateX(-15deg);
            transition: all 1s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            inset: -2px;
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.3), rgba(255, 0, 255, 0.3));
            border-radius: inherit;
            z-index: -1;
            opacity: 0;
            filter: blur(10px);
            transition: opacity 0.5s ease;
        }

        .stat-card:hover {
            border-color: rgba(0, 255, 255, 0.4);
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 40px rgba(0, 255, 255, 0.3);
        }

        .stat-card:hover::before {
            opacity: 1;
        }

        .active .stat-card:nth-child(1) { transition-delay: 0.4s; }
        .active .stat-card:nth-child(2) { transition-delay: 0.5s; }
        .active .stat-card:nth-child(3) { transition-delay: 0.6s; }

        .active .stat-card {
            opacity: 1;
            transform: translateY(0) rotateX(0);
        }

        .stat-number {
            font-family: var(--font-display);
            font-size: 3.5rem;
            font-weight: 900;
            color: var(--cyan);
            margin-bottom: 10px;
        }

        .stat-label {
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.6);
        }

        /* ACCENT TEXT */
        .accent {
            color: var(--cyan);
            font-weight: 700;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            position: relative;
        }

        .highlight {
            color: var(--magenta);
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
            position: relative;
        }

        /* Holographic text shimmer effect */
        .accent::before, .highlight::before {
            content: attr(data-text);
            position: absolute;
            left: 0;
            top: 0;
            z-index: -1;
            filter: blur(10px);
            opacity: 0.6;
        }

        /* VISUAL NAVIGATION HINTS */
        .section-hint {
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            padding: 12px 24px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 30px;
            font-size: 0.9rem;
            color: var(--cyan);
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }

        .section-hint.visible {
            opacity: 1;
        }

        /* PROGRESS DOTS */
        .progress-dots {
            position: fixed;
            right: 40px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid rgba(0, 255, 255, 0.3);
            background: transparent;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .progress-dot.active {
            background: var(--cyan);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            transform: scale(1.5);
        }

        /* TICK DEBUG */
        .tick-debug {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.85);
            padding: 16px 22px;
            border-radius: 12px;
            border: 1px solid var(--cyan);
            font-family: 'Courier New', monospace;
            font-size: 0.95rem;
            color: var(--cyan);
        }

        .tick-debug span {
            display: block;
            margin: 5px 0;
        }

        .tick-debug strong {
            color: var(--magenta);
        }
    </style>
</head>
<body>
    <!-- VIB3+ Quantum Visualizer -->
    <div class="quantum-layers" id="quantum-layers">
        <canvas id="quantum-background" class="quantum-canvas"></canvas>
        <canvas id="quantum-shadow" class="quantum-canvas"></canvas>
        <canvas id="quantum-content" class="quantum-canvas"></canvas>
        <canvas id="quantum-highlight" class="quantum-canvas"></canvas>
        <canvas id="quantum-accent" class="quantum-canvas"></canvas>
    </div>

    <!-- Content Container - Always Centered -->
    <div id="content-container">
        <div class="content-wrapper">
            <div class="card-stage" id="card-stage">
                <div class="morph-card active" id="morph-card">
                    <div class="card-bg-accent"></div>
                    <div id="section-content">
                        <!-- Content injected by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- UI Elements -->
    <div class="section-hint" id="section-hint"></div>
    <div class="progress-dots" id="progress-dots"></div>

    <div class="tick-debug">
        <span>Section: <strong id="debug-section">0</strong></span>
        <span>Ticks: <strong id="debug-ticks">0 / 5</strong></span>
        <span>Vis Offset: <strong id="debug-offset">0</strong></span>
        <span>Density: <strong id="debug-density">40</strong></span>
        <span>Rot4dXW: <strong id="debug-rot">0.00</strong></span>
    </div>

    <script type="module">
        // ========== SECTION DEFINITIONS WITH COMPLETE VIB3+ ORCHESTRATION ==========
        const SECTIONS = [
            {
                id: 0,
                content: `
                    <h1>MINOOTS</h1>
                    <div class="subtitle">Independent Timer System for Autonomous Agents</div>
                    <p class="body-text">
                        A production-ready timer system that runs independently of your main application.
                        <span class="accent">Survive crashes, scale infinitely, coordinate autonomously.</span>
                    </p>
                `,
                // CARD CHOREOGRAPHY
                cards: {
                    count: 1, // Single card for intro
                    splitAnimation: 'fade-scale'
                },
                // COMPLETE 17+ PARAMETER SYSTEM PER LAYER
                layers: {
                    background: {
                        geometry: 1, // Hypersphere
                        gridDensity: 8.0,
                        morphFactor: 0.3,
                        dimension: 3.5,
                        rotationSpeed: 0.2,
                        lineThickness: 0.015,
                        patternIntensity: 0.4,
                        universeModifier: 0.8,
                        glitchIntensity: 0.0,
                        colorShift: 0.0,
                        rot4dXW: 0.0,
                        rot4dYW: 0.0,
                        rot4dZW: 0.0,
                        offsetY: 0.0
                    },
                    shadow: {
                        geometry: 1,
                        gridDensity: 10.0,
                        morphFactor: 0.4,
                        dimension: 3.6,
                        rotationSpeed: 0.3,
                        lineThickness: 0.02,
                        patternIntensity: 0.5,
                        universeModifier: 0.9,
                        glitchIntensity: 0.02,
                        colorShift: 0.1
                    },
                    content: {
                        geometry: 1,
                        gridDensity: 12.0,
                        morphFactor: 0.5,
                        dimension: 3.8,
                        rotationSpeed: 0.4,
                        lineThickness: 0.025,
                        patternIntensity: 0.7,
                        universeModifier: 1.0,
                        glitchIntensity: 0.03,
                        colorShift: 0.0
                    },
                    highlight: {
                        geometry: 1,
                        gridDensity: 15.0,
                        morphFactor: 0.7,
                        dimension: 4.0,
                        rotationSpeed: 0.6,
                        lineThickness: 0.03,
                        patternIntensity: 0.9,
                        universeModifier: 1.2,
                        glitchIntensity: 0.05,
                        colorShift: 0.2
                    },
                    accent: {
                        geometry: 1,
                        gridDensity: 18.0,
                        morphFactor: 0.9,
                        dimension: 4.2,
                        rotationSpeed: 0.8,
                        lineThickness: 0.035,
                        patternIntensity: 1.1,
                        universeModifier: 1.4,
                        glitchIntensity: 0.08,
                        colorShift: -0.3
                    }
                },
                // ELEMENT TAKEOVER CONFIGURATION
                elementTakeover: {
                    enabled: false,
                    blendMode: 'screen',
                    intensity: 0.0
                },
                cardStyle: {
                    borderRadius: '50%',
                    aspectRatio: '1',
                    maxWidth: '650px',
                    '--accent-x': '30%',
                    '--accent-y': '40%'
                }
            },
            {
                id: 1,
                content: `
                    <h2>Agent-First Architecture</h2>
                    <div class="subtitle">Built for AI Agents & Enterprise Workflows</div>
                    <p class="body-text">
                        <span class="accent">Durable independence:</span> Timer state persists across infrastructure failures and process restarts.
                        Your agents keep their memory, even when systems crash.
                    </p>
                    <p class="body-text">
                        <span class="highlight">Zero-trust multitenancy:</span> Full audit trails, tenant-isolated credentials,
                        and policy enforcement at every layer.
                    </p>
                `,
                // CARD SPLITS INTO 2
                cards: {
                    count: 2,
                    splitAnimation: 'slide-split',
                    contents: [
                        `<h2>Distributed</h2><p class="body-text">50M+ concurrent timers</p>`,
                        `<h2>Horology</h2><p class="body-text">Â±50ms precision</p>`
                    ]
                },
                // UNIQUE PARAMETERS PER LAYER WITH TORUS GEOMETRY
                layers: {
                    background: {
                        geometry: 2, // Torus
                        gridDensity: 6.0,
                        morphFactor: 0.4,
                        dimension: 3.6,
                        rotationSpeed: 0.3,
                        lineThickness: 0.018,
                        patternIntensity: 0.5,
                        universeModifier: 1.0,
                        glitchIntensity: 0.02,
                        colorShift: 0.15,
                        rot4dXW: 0.2,
                        rot4dYW: 0.15,
                        rot4dZW: 0.1
                    },
                    shadow: {
                        geometry: 2,
                        gridDensity: 9.0,
                        morphFactor: 0.6,
                        dimension: 3.8,
                        rotationSpeed: 0.45,
                        lineThickness: 0.022,
                        patternIntensity: 0.65,
                        universeModifier: 1.1,
                        glitchIntensity: 0.04,
                        colorShift: 0.2
                    },
                    content: {
                        geometry: 2,
                        gridDensity: 12.0,
                        morphFactor: 0.8,
                        dimension: 4.0,
                        rotationSpeed: 0.6,
                        lineThickness: 0.028,
                        patternIntensity: 0.85,
                        universeModifier: 1.3,
                        glitchIntensity: 0.06,
                        colorShift: 0.1
                    },
                    highlight: {
                        geometry: 2,
                        gridDensity: 16.0,
                        morphFactor: 1.0,
                        dimension: 4.3,
                        rotationSpeed: 0.8,
                        lineThickness: 0.032,
                        patternIntensity: 1.1,
                        universeModifier: 1.5,
                        glitchIntensity: 0.09,
                        colorShift: -0.2
                    },
                    accent: {
                        geometry: 2,
                        gridDensity: 20.0,
                        morphFactor: 1.2,
                        dimension: 4.5,
                        rotationSpeed: 1.1,
                        lineThickness: 0.038,
                        patternIntensity: 1.4,
                        universeModifier: 1.8,
                        glitchIntensity: 0.12,
                        colorShift: 0.4
                    }
                },
                // ELEMENT TAKEOVER BEGINS
                elementTakeover: {
                    enabled: true,
                    blendMode: 'screen',
                    intensity: 0.2,
                    particleCount: 50
                },
                cardStyle: {
                    borderRadius: '120px',
                    aspectRatio: '16/10',
                    maxWidth: '750px',
                    '--accent-x': '70%',
                    '--accent-y': '30%'
                }
            },
            {
                id: 2,
                content: `
                    <h2>Four-Layer System</h2>
                    <p class="body-text">
                        <span class="accent">Control Plane:</span> REST API with multi-tenant validation, authentication & RBAC policies
                    </p>
                    <p class="body-text">
                        <span class="highlight">Horology Kernel:</span> Rust/Tokio scheduler with timing wheels, Raft consensus & PostgreSQL persistence
                    </p>
                    <p class="body-text">
                        <span class="accent">Event Fabric:</span> NATS JetStream + Kafka for ordered event delivery with replay & idempotency
                    </p>
                    <p class="body-text">
                        <span class="highlight">Action Orchestrator:</span> Webhooks, CLI commands, file operations, agent notifications
                    </p>
                `,
                visualizer: {
                    geometry: 3,
                    baseDensity: 30,
                    baseRot4dXW: 1.0,
                    baseRot4dYW: 0.7,
                    baseRot4dZW: 0.5,
                    chaos: 0.3,
                    speed: 1.2,
                    intensity: 0.7,
                    hue: 0.65 // Cyan-magenta
                },
                cardStyle: {
                    borderRadius: '80px',
                    aspectRatio: '16/9',
                    maxWidth: '850px',
                    '--accent-x': '50%',
                    '--accent-y': '60%'
                }
            },
            {
                id: 3,
                content: `
                    <h2>Production-Ready Performance</h2>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-number">50M+</div>
                            <div class="stat-label">Concurrent Timers</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">Â±50ms</div>
                            <div class="stat-label">Sub-Second Precision</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">99.99%</div>
                            <div class="stat-label">Uptime Guarantee</div>
                        </div>
                    </div>
                    <p class="body-text" style="margin-top: 30px;">
                        Trigger accuracy stays within sub-second tolerances even at scale.
                        <span class="accent">Event replay and idempotency built in.</span>
                    </p>
                `,
                visualizer: {
                    geometry: 7,
                    baseDensity: 25,
                    baseRot4dXW: 1.5,
                    baseRot4dYW: 1.2,
                    baseRot4dZW: 0.8,
                    chaos: 0.4,
                    speed: 1.4,
                    intensity: 0.8,
                    hue: 0.7 // Magenta
                },
                cardStyle: {
                    borderRadius: '60px',
                    aspectRatio: 'auto',
                    maxWidth: '900px',
                    '--accent-x': '40%',
                    '--accent-y': '50%'
                }
            },
            {
                id: 4,
                content: `
                    <h2>Universal Integration</h2>
                    <p class="body-text">
                        <span class="accent">LangChain â€¢ AutoGen â€¢ LlamaIndex â€¢ Swarm.js</span>
                    </p>
                    <p class="body-text">
                        Composable orchestration with multiple LLM frameworks. Timers coordinate both
                        individual agents and agent swarms through <span class="highlight">standardized command interfaces.</span>
                    </p>
                    <p class="body-text">
                        <span class="accent">MCP Protocol â€¢ GitHub Actions â€¢ Slack Bot â€¢ REST API</span>
                    </p>
                    <p class="body-text">
                        Claude Code compatible. CI/CD ready. Human-friendly.
                    </p>
                `,
                visualizer: {
                    geometry: 7,
                    baseDensity: 22,
                    baseRot4dXW: 2.0,
                    baseRot4dYW: 1.5,
                    baseRot4dZW: 1.0,
                    chaos: 0.3,
                    speed: 1.1,
                    intensity: 0.7,
                    hue: 0.75 // Magenta-red
                },
                cardStyle: {
                    borderRadius: '50px',
                    aspectRatio: 'auto',
                    maxWidth: '850px',
                    '--accent-x': '60%',
                    '--accent-y': '40%'
                }
            },
            {
                id: 5,
                content: `
                    <h2>Simple API, Powerful Results</h2>
                    <p class="body-text">
                        <span class="accent">Duration formats:</span> '30s' â€¢ '5m' â€¢ '2h' â€¢ '1d' â€¢ 3600000ms
                    </p>
                    <p class="body-text">
                        <span class="highlight">Action types:</span> HTTP webhooks â€¢ CLI commands â€¢ File writes â€¢ Agent notifications
                    </p>
                    <p class="body-text">
                        Create, monitor, cancel. Real-time progress tracking.
                        Firebase backend for <span class="accent">global synchronization.</span>
                    </p>
                    <p class="body-text">
                        Team collaboration with enterprise authentication.
                        <span class="highlight">Works across all your infrastructure.</span>
                    </p>
                `,
                visualizer: {
                    geometry: 10,
                    baseDensity: 20,
                    baseRot4dXW: 2.5,
                    baseRot4dYW: 2.0,
                    baseRot4dZW: 1.5,
                    chaos: 0.5,
                    speed: 1.3,
                    intensity: 0.75,
                    hue: 0.8 // Purple
                },
                cardStyle: {
                    borderRadius: '50px',
                    aspectRatio: 'auto',
                    maxWidth: '850px',
                    '--accent-x': '35%',
                    '--accent-y': '55%'
                }
            },
            {
                id: 6,
                content: `
                    <h1>Wake-Up Signals for AI</h1>
                    <div class="subtitle">Long-horizon coordination with full auditability</div>
                    <p class="body-text">
                        Timers function as <span class="accent">wake-up signals</span> that inject contextual commands
                        into agent decision cycles, enabling long-horizon coordination while maintaining
                        auditability and recovery from partial failures.
                    </p>
                    <p class="body-text">
                        <span class="highlight">Time is now autonomous.</span>
                    </p>
                    <p class="body-text" style="margin-top: 40px; font-size: 1.2rem;">
                        <span class="accent">api-m3waemr5lq-uc.a.run.app</span>
                    </p>
                `,
                visualizer: {
                    geometry: 15,
                    baseDensity: 18,
                    baseRot4dXW: 3.0,
                    baseRot4dYW: 2.5,
                    baseRot4dZW: 2.0,
                    chaos: 0.6,
                    speed: 1.6,
                    intensity: 0.9,
                    hue: 0.85 // Magenta-purple
                },
                cardStyle: {
                    borderRadius: '40px',
                    aspectRatio: 'auto',
                    maxWidth: '900px',
                    '--accent-x': '50%',
                    '--accent-y': '50%'
                }
            }
        ];

        // ========== VIB3+ QUANTUM VISUALIZER ==========
        class QuantumVisualizer {
            constructor(canvasId, role, reactivity) {
                this.canvas = document.getElementById(canvasId);
                this.role = role;
                this.reactivity = reactivity;

                this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl');
                if (!this.gl) return;

                this.startTime = Date.now();
                this.params = {
                    geometry: 1,
                    gridDensity: 40,
                    morphFactor: 1.0,
                    chaos: 0.2,
                    speed: 1.0,
                    hue: 0.556,
                    intensity: 0.5,
                    saturation: 0.8,
                    dimension: 3.5,
                    rot4dXW: 0.0,
                    rot4dYW: 0.0,
                    rot4dZW: 0.0,
                    offsetY: 0.0
                };

                this.init();
            }

            init() {
                this.initShaders();
                this.initBuffers();
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            initShaders() {
                const vertexShader = `
                    attribute vec2 a_position;
                    void main() {
                        gl_Position = vec4(a_position, 0.0, 1.0);
                    }
                `;

                const fragmentShader = `
                    #ifdef GL_FRAGMENT_PRECISION_HIGH
                        precision highp float;
                    #else
                        precision mediump float;
                    #endif

                    uniform vec2 u_resolution;
                    uniform float u_time;
                    uniform float u_geometry;
                    uniform float u_gridDensity;
                    uniform float u_chaos;
                    uniform float u_speed;
                    uniform float u_hue;
                    uniform float u_intensity;
                    uniform float u_rot4dXW;
                    uniform float u_rot4dYW;
                    uniform float u_rot4dZW;
                    uniform float u_roleIntensity;
                    uniform float u_offsetY;

                    mat4 rotateXW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(c, 0.0, 0.0, -s, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, s, 0.0, 0.0, c);
                    }

                    mat4 rotateYW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(1.0, 0.0, 0.0, 0.0, 0.0, c, 0.0, -s, 0.0, 0.0, 1.0, 0.0, 0.0, s, 0.0, c);
                    }

                    mat4 rotateZW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, c, -s, 0.0, 0.0, s, c);
                    }

                    vec3 project4Dto3D(vec4 p) {
                        float w = 2.5 / (2.5 + p.w);
                        return vec3(p.x * w, p.y * w, p.z * w);
                    }

                    vec3 warpHypersphere(vec3 p) {
                        float radius = length(p);
                        float w = sin(radius * 1.5 + u_time * 0.0008 * u_speed) * 0.6;
                        vec4 p4d = vec4(p, w);
                        p4d = rotateXW(u_rot4dXW) * p4d;
                        p4d = rotateYW(u_rot4dYW) * p4d;
                        p4d = rotateZW(u_rot4dZW) * p4d;
                        return project4Dto3D(p4d);
                    }

                    float hypercubeLattice(vec3 p, float gridSize) {
                        vec3 grid = fract(p * gridSize);
                        vec3 edges = min(grid, 1.0 - grid);
                        float minEdge = min(min(edges.x, edges.y), edges.z);
                        return 1.0 - smoothstep(0.0, 0.03, minEdge);
                    }

                    float sphereLattice(vec3 p, float gridSize) {
                        vec3 cell = fract(p * gridSize) - 0.5;
                        return 1.0 - smoothstep(0.15, 0.25, length(cell));
                    }

                    float torusLattice(vec3 p, float gridSize) {
                        vec3 cell = fract(p * gridSize) - 0.5;
                        float toroidalDist = length(vec2(length(cell.xy) - 0.3, cell.z));
                        return 1.0 - smoothstep(0.08, 0.12, toroidalDist);
                    }

                    float waveLattice(vec3 p, float gridSize) {
                        float time = u_time * 0.001 * u_speed;
                        float wave = sin(p.x * gridSize * 2.0 + time * 2.0) +
                                   sin(p.y * gridSize * 1.8 + time * 1.5) +
                                   sin(p.z * gridSize * 2.2 + time * 1.8);
                        return max(0.0, wave / 3.0);
                    }

                    float geometryFunction(vec4 p) {
                        vec3 p3d = project4Dto3D(p);
                        vec3 warped = warpHypersphere(p3d);
                        float gridSize = u_gridDensity * 0.08;

                        int geomType = int(mod(u_geometry, 8.0));

                        if (geomType == 0) return hypercubeLattice(warped, gridSize);
                        else if (geomType == 1) return sphereLattice(warped, gridSize);
                        else if (geomType == 2) return torusLattice(warped, gridSize);
                        else if (geomType == 3) return waveLattice(warped, gridSize);
                        else return hypercubeLattice(warped, gridSize);
                    }

                    vec3 getLayerColor(int layerIndex, float hueShift) {
                        if (layerIndex == 0) return vec3(0.05, 0.0, 0.2);
                        else if (layerIndex == 1) return vec3(0.0, 0.3, 0.3);
                        else if (layerIndex == 2) return mix(vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 1.0), hueShift);
                        else if (layerIndex == 3) return vec3(0.0, 1.0, 1.0);
                        else return vec3(1.0, 0.0, 1.0);
                    }

                    void main() {
                        vec2 uv = (gl_FragCoord.xy - u_resolution.xy * 0.5) / min(u_resolution.x, u_resolution.y);
                        uv.y += u_offsetY;

                        float timeSpeed = u_time * 0.0001 * u_speed;
                        vec4 pos = vec4(uv * 3.0, sin(timeSpeed * 3.0), cos(timeSpeed * 2.0));

                        pos = rotateXW(u_rot4dXW) * pos;
                        pos = rotateYW(u_rot4dYW) * pos;
                        pos = rotateZW(u_rot4dZW) * pos;

                        float value = geometryFunction(pos);
                        float noise = sin(pos.x * 7.0) * cos(pos.y * 11.0);
                        value += noise * u_chaos;

                        float geometryIntensity = 1.0 - clamp(abs(value * 0.8), 0.0, 1.0);
                        geometryIntensity = pow(geometryIntensity, 1.5);
                        float finalIntensity = geometryIntensity * u_intensity;

                        int layerIndex = u_roleIntensity == 0.4 ? 0 :
                                       u_roleIntensity == 0.6 ? 1 :
                                       u_roleIntensity == 1.0 ? 2 :
                                       u_roleIntensity == 1.3 ? 3 : 4;

                        vec3 layerColor = getLayerColor(layerIndex, u_hue);
                        vec3 finalColor = layerColor * finalIntensity;

                        float layerAlpha = u_roleIntensity == 1.0 ? 1.0 :
                                         u_roleIntensity == 1.3 ? 0.8 :
                                         u_roleIntensity == 1.6 ? 0.3 :
                                         u_roleIntensity == 0.6 ? 0.4 : 0.6;

                        gl_FragColor = vec4(finalColor, finalIntensity * layerAlpha);
                    }
                `;

                this.program = this.createProgram(vertexShader, fragmentShader);

                this.uniforms = {
                    resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
                    time: this.gl.getUniformLocation(this.program, 'u_time'),
                    geometry: this.gl.getUniformLocation(this.program, 'u_geometry'),
                    gridDensity: this.gl.getUniformLocation(this.program, 'u_gridDensity'),
                    chaos: this.gl.getUniformLocation(this.program, 'u_chaos'),
                    speed: this.gl.getUniformLocation(this.program, 'u_speed'),
                    hue: this.gl.getUniformLocation(this.program, 'u_hue'),
                    intensity: this.gl.getUniformLocation(this.program, 'u_intensity'),
                    rot4dXW: this.gl.getUniformLocation(this.program, 'u_rot4dXW'),
                    rot4dYW: this.gl.getUniformLocation(this.program, 'u_rot4dYW'),
                    rot4dZW: this.gl.getUniformLocation(this.program, 'u_rot4dZW'),
                    roleIntensity: this.gl.getUniformLocation(this.program, 'u_roleIntensity'),
                    offsetY: this.gl.getUniformLocation(this.program, 'u_offsetY')
                };
            }

            createProgram(vertexSource, fragmentSource) {
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);

                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);

                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) return null;
                return program;
            }

            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) return null;
                return shader;
            }

            initBuffers() {
                const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
                this.buffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);

                const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
                this.gl.enableVertexAttribArray(positionLocation);
                this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
            }

            resize() {
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                this.canvas.width = this.canvas.clientWidth * dpr;
                this.canvas.height = this.canvas.clientHeight * dpr;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            updateParameters(params) {
                Object.assign(this.params, params);
            }

            render() {
                if (!this.program) return;

                this.gl.useProgram(this.program);
                this.gl.clearColor(0, 0, 0, 0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT);

                const roleIntensities = {
                    'background': 0.4,
                    'shadow': 0.6,
                    'content': 1.0,
                    'highlight': 1.3,
                    'accent': 1.6
                };

                const time = Date.now() - this.startTime;

                this.gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
                this.gl.uniform1f(this.uniforms.time, time);
                this.gl.uniform1f(this.uniforms.geometry, this.params.geometry);
                this.gl.uniform1f(this.uniforms.gridDensity, this.params.gridDensity);
                this.gl.uniform1f(this.uniforms.chaos, this.params.chaos);
                this.gl.uniform1f(this.uniforms.speed, this.params.speed);
                this.gl.uniform1f(this.uniforms.hue, this.params.hue);
                this.gl.uniform1f(this.uniforms.intensity, this.params.intensity);
                this.gl.uniform1f(this.uniforms.rot4dXW, this.params.rot4dXW);
                this.gl.uniform1f(this.uniforms.rot4dYW, this.params.rot4dYW);
                this.gl.uniform1f(this.uniforms.rot4dZW, this.params.rot4dZW);
                this.gl.uniform1f(this.uniforms.roleIntensity, roleIntensities[this.role] || 1.0);
                this.gl.uniform1f(this.uniforms.offsetY, this.params.offsetY);

                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
            }
        }

        // ========== SCROLL CONTROLLER ==========
        class ScrollController {
            constructor() {
                this.currentSection = 0;
                this.currentTick = 0;
                this.ticksPerSection = 5;
                this.isTransitioning = false;
                this.scrollCooldown = false;

                this.morphCard = document.getElementById('morph-card');
                this.sectionContent = document.getElementById('section-content');
                this.sectionHint = document.getElementById('section-hint');

                this.createProgressDots();
                this.initGSAPAnimations();
                this.loadSection(0);
                this.setupEventListeners();

                console.log('ðŸŽ¬ Scroll Controller Ready');
            }

            initGSAPAnimations() {
                // Initialize GSAP with smooth defaults
                gsap.defaults({
                    ease: "power2.out",
                    duration: 0.8
                });

                // Mouse parallax effect for depth
                this.setupMouseParallax();

                // Show initial hint after a delay
                setTimeout(() => {
                    this.showHint('Scroll to discover MINOOTS');
                }, 2000);
            }

            setupMouseParallax() {
                const quantumLayers = document.getElementById('quantum-layers');
                const cardStage = document.getElementById('card-stage');

                document.addEventListener('mousemove', (e) => {
                    const x = (e.clientX / window.innerWidth - 0.5) * 2;
                    const y = (e.clientY / window.innerHeight - 0.5) * 2;

                    // Subtle parallax on visualizer
                    gsap.to(quantumLayers, {
                        x: x * 20,
                        y: y * 20,
                        duration: 1.5,
                        ease: "power2.out"
                    });

                    // Card parallax with depth
                    const cards = cardStage.querySelectorAll('.morph-card');
                    cards.forEach((card, index) => {
                        const depth = (index + 1) * 0.5;
                        gsap.to(card, {
                            rotateY: x * 8 * depth,
                            rotateX: -y * 8 * depth,
                            duration: 1.2,
                            ease: "power2.out"
                        });

                        // Parallax on depth layer
                        const depthLayer = card.querySelector('.card-depth-layer');
                        if (depthLayer) {
                            gsap.to(depthLayer, {
                                x: x * 30 * depth,
                                y: y * 30 * depth,
                                duration: 2,
                                ease: "power1.out"
                            });
                        }
                    });
                });

                // Enhanced card hover interactions
                this.setupCardHoverEffects();
            }

            setupCardHoverEffects() {
                document.addEventListener('mouseover', (e) => {
                    const card = e.target.closest('.morph-card');
                    if (!card) return;

                    // Enhance glow on hover
                    gsap.to(card, {
                        boxShadow: '0 0 140px rgba(0, 255, 255, 0.5), 0 0 80px rgba(255, 0, 255, 0.35), inset 0 0 100px rgba(0, 255, 255, 0.15), inset 0 0 50px rgba(255, 0, 255, 0.1), 0 40px 100px rgba(0, 0, 0, 0.7)',
                        duration: 0.6,
                        ease: "power2.out"
                    });

                    // Brighten accent layer
                    const accent = card.querySelector('.card-bg-accent');
                    if (accent) {
                        gsap.to(accent, {
                            opacity: 1.2,
                            duration: 0.6,
                            ease: "power2.out"
                        });
                    }
                });

                document.addEventListener('mouseout', (e) => {
                    const card = e.target.closest('.morph-card');
                    if (!card) return;

                    gsap.to(card, {
                        boxShadow: '0 0 80px rgba(0, 255, 255, 0.25), 0 0 40px rgba(255, 0, 255, 0.15), inset 0 0 60px rgba(0, 255, 255, 0.08), inset 0 0 30px rgba(255, 0, 255, 0.05), 0 20px 60px rgba(0, 0, 0, 0.5)',
                        duration: 0.6,
                        ease: "power2.in"
                    });

                    const accent = card.querySelector('.card-bg-accent');
                    if (accent) {
                        gsap.to(accent, {
                            opacity: 0,
                            duration: 0.6,
                            ease: "power2.in"
                        });
                    }
                });
            }

            showHint(text) {
                this.sectionHint.textContent = text;
                gsap.to(this.sectionHint, {
                    opacity: 1,
                    duration: 0.5,
                    ease: "power2.out"
                });

                // Auto-hide after 3 seconds
                setTimeout(() => {
                    gsap.to(this.sectionHint, {
                        opacity: 0,
                        duration: 0.5,
                        ease: "power2.in"
                    });
                }, 3000);
            }

            createProgressDots() {
                const container = document.getElementById('progress-dots');
                SECTIONS.forEach((_, i) => {
                    const dot = document.createElement('div');
                    dot.className = 'progress-dot' + (i === 0 ? ' active' : '');
                    dot.addEventListener('click', () => this.jumpToSection(i));
                    container.appendChild(dot);
                });
                this.progressDots = container.querySelectorAll('.progress-dot');
            }

            setupEventListeners() {
                document.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.handleScroll(e.deltaY);
                }, { passive: false });

                let touchStartY = 0;
                document.addEventListener('touchstart', (e) => {
                    touchStartY = e.touches[0].clientY;
                });

                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const delta = touchStartY - e.touches[0].clientY;
                    if (Math.abs(delta) > 30) {
                        this.handleScroll(delta);
                        touchStartY = e.touches[0].clientY;
                    }
                }, { passive: false });
            }

            handleScroll(delta) {
                if (this.scrollCooldown || this.isTransitioning) return;

                const direction = delta > 0 ? 1 : -1;
                this.currentTick += direction;

                // Hide hint on first scroll
                if (this.sectionHint) {
                    gsap.to(this.sectionHint, { opacity: 0, duration: 0.3 });
                }

                this.updatePerTickChoreography();

                if (this.currentTick >= this.ticksPerSection) {
                    if (this.currentSection < SECTIONS.length - 1) {
                        this.currentSection++;
                        this.currentTick = 0;
                        this.transitionToSection(this.currentSection);
                    } else {
                        this.currentTick = this.ticksPerSection - 1;
                    }
                } else if (this.currentTick < 0) {
                    if (this.currentSection > 0) {
                        this.currentSection--;
                        this.currentTick = this.ticksPerSection - 1;
                        this.transitionToSection(this.currentSection);
                    } else {
                        this.currentTick = 0;
                    }
                }

                this.updateDebug();
                this.scrollCooldown = true;
                setTimeout(() => this.scrollCooldown = false, 100);
            }

            updatePerTickChoreography() {
                const section = SECTIONS[this.currentSection];
                const progress = this.currentTick / (this.ticksPerSection - 1);

                // SMOOTH EASING FUNCTIONS FOR GRACEFUL CHOREOGRAPHY
                const easeInOutCubic = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                const easeOutQuart = t => 1 - Math.pow(1 - t, 4);
                const easeInOutSine = t => -(Math.cos(Math.PI * t) - 1) / 2;

                const smoothProgress = easeInOutCubic(progress);
                const floatyProgress = easeInOutSine(progress);
                const dynamicProgress = easeOutQuart(progress);

                // UPDATE EACH LAYER INDEPENDENTLY WITH UNIQUE CHOREOGRAPHY
                window.quantumVisualizers.forEach(viz => {
                    const layerConfig = section.layers[viz.role];
                    if (!layerConfig) return;

                    // CALCULATE PROGRESSIVE PARAMETER EVOLUTION
                    const baseOffsetY = layerConfig.offsetY || 0;
                    const progressiveOffsetY = baseOffsetY + (floatyProgress * -0.5);

                    // DENSITY EVOLUTION WITH LAYER-SPECIFIC VARIANCE
                    const layerDensityMultiplier = {
                        'background': 0.7,
                        'shadow': 0.85,
                        'content': 1.0,
                        'highlight': 1.15,
                        'accent': 1.3
                    }[viz.role] || 1.0;

                    const densityDrop = progress * 8 * layerDensityMultiplier;
                    const progressiveGridDensity = Math.max(
                        layerConfig.gridDensity * 0.3,
                        layerConfig.gridDensity - densityDrop
                    );

                    // 4D ROTATION CHOREOGRAPHY - UNIQUE PER LAYER
                    const baseRot4dXW = layerConfig.rot4dXW || 0;
                    const baseRot4dYW = layerConfig.rot4dYW || 0;
                    const baseRot4dZW = layerConfig.rot4dZW || 0;

                    const rot4dXW = baseRot4dXW + (Math.sin(smoothProgress * Math.PI) * 0.4 * layerDensityMultiplier);
                    const rot4dYW = baseRot4dYW + (Math.cos(dynamicProgress * Math.PI * 0.7) * 0.3 * layerDensityMultiplier);
                    const rot4dZW = baseRot4dZW + (smoothProgress * 0.5 * layerDensityMultiplier);

                    // MORPH FACTOR EVOLUTION
                    const progressiveMorphFactor = layerConfig.morphFactor + (dynamicProgress * 0.3);

                    // DIMENSION EVOLUTION (3D â†’ 4D+ HYPERCUBE)
                    const progressiveDimension = layerConfig.dimension + (smoothProgress * 0.5);

                    // ROTATION SPEED CHOREOGRAPHY
                    const progressiveRotationSpeed = layerConfig.rotationSpeed * (1.0 + floatyProgress * 0.4);

                    // PATTERN INTENSITY MODULATION
                    const progressivePatternIntensity = layerConfig.patternIntensity * (1.0 + progress * 0.3);

                    // GLITCH INTENSITY BUILDUP
                    const progressiveGlitchIntensity = layerConfig.glitchIntensity + (Math.pow(progress, 2) * 0.05);

                    // COLOR SHIFT EVOLUTION
                    const progressiveColorShift = layerConfig.colorShift + (Math.sin(progress * Math.PI) * 0.2);

                    // APPLY COMPLETE PARAMETER SET TO THIS LAYER
                    viz.updateParameters({
                        geometry: layerConfig.geometry,
                        gridDensity: progressiveGridDensity,
                        morphFactor: progressiveMorphFactor,
                        dimension: progressiveDimension,
                        rotationSpeed: progressiveRotationSpeed,
                        lineThickness: layerConfig.lineThickness,
                        patternIntensity: progressivePatternIntensity,
                        universeModifier: layerConfig.universeModifier,
                        glitchIntensity: progressiveGlitchIntensity,
                        colorShift: progressiveColorShift,
                        rot4dXW,
                        rot4dYW,
                        rot4dZW,
                        offsetY: progressiveOffsetY,
                        // Legacy compatibility
                        chaos: progressiveGlitchIntensity * 3.0,
                        speed: progressiveRotationSpeed,
                        intensity: progressivePatternIntensity,
                        hue: 0.556 + (progressiveColorShift * 0.1)
                    });
                });

                // CARD CHOREOGRAPHY
                this.updateCardChoreography(progress, smoothProgress);
            }

            updateCardChoreography(progress, smoothProgress) {
                const section = SECTIONS[this.currentSection];
                const cardStage = document.getElementById('card-stage');

                // CARD MORPHING WITH SMOOTH PROGRESS
                const cards = cardStage.querySelectorAll('.morph-card');

                cards.forEach((card, index) => {
                    // INDIVIDUAL CARD CHOREOGRAPHY
                    const cardDelay = index * 0.1;
                    const cardProgress = Math.max(0, Math.min(1, (progress - cardDelay) / (1 - cardDelay)));
                    const cardSmooth = Math.pow(cardProgress, 1.5);

                    // 3D TRANSFORM CHOREOGRAPHY with GSAP-style easing
                    const rotateY = Math.sin(smoothProgress * Math.PI) * 10;
                    const rotateX = Math.cos(smoothProgress * Math.PI * 0.7) * 5;
                    const translateZ = cardSmooth * 30;
                    const scale = 1.0 + (Math.sin(cardProgress * Math.PI) * 0.03);

                    // Smooth transition with cubic-bezier similar to GSAP
                    card.style.transition = 'transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.4s ease, box-shadow 0.5s ease';

                    card.style.transform = `
                        perspective(2000px)
                        rotateY(${rotateY}deg)
                        rotateX(${rotateX}deg)
                        translateZ(${translateZ}px)
                        scale(${scale})
                    `;

                    // OPACITY PULSING - more subtle
                    const opacityPulse = 0.95 + (Math.sin(progress * Math.PI * 2) * 0.05);
                    card.style.opacity = opacityPulse;

                    // BORDER GLOW INTENSITY - smoother progression
                    const glowIntensity = 0.2 + (smoothProgress * 0.2);
                    card.style.boxShadow = `
                        0 0 ${60 + smoothProgress * 30}px rgba(0, 255, 255, ${glowIntensity}),
                        inset 0 0 ${40 + smoothProgress * 15}px rgba(0, 255, 255, ${glowIntensity * 0.25})
                    `;
                });
            }

            transitionToSection(index) {
                this.isTransitioning = true;

                this.progressDots.forEach((dot, i) => {
                    dot.classList.toggle('active', i === index);
                });

                this.loadSection(index);

                // UPDATE EACH LAYER INDEPENDENTLY WITH NEW SECTION CONFIGURATION
                const section = SECTIONS[index];
                window.quantumVisualizers.forEach(viz => {
                    const layerConfig = section.layers[viz.role];
                    if (!layerConfig) return;

                    viz.updateParameters({
                        geometry: layerConfig.geometry,
                        gridDensity: layerConfig.gridDensity,
                        morphFactor: layerConfig.morphFactor,
                        dimension: layerConfig.dimension,
                        rotationSpeed: layerConfig.rotationSpeed,
                        lineThickness: layerConfig.lineThickness,
                        patternIntensity: layerConfig.patternIntensity,
                        universeModifier: layerConfig.universeModifier,
                        glitchIntensity: layerConfig.glitchIntensity,
                        colorShift: layerConfig.colorShift,
                        rot4dXW: layerConfig.rot4dXW || 0,
                        rot4dYW: layerConfig.rot4dYW || 0,
                        rot4dZW: layerConfig.rot4dZW || 0,
                        offsetY: 0.0,
                        // Legacy compatibility
                        chaos: layerConfig.glitchIntensity * 3.0,
                        speed: layerConfig.rotationSpeed,
                        intensity: layerConfig.patternIntensity,
                        hue: 0.556 + (layerConfig.colorShift * 0.1)
                    });
                });

                setTimeout(() => {
                    this.isTransitioning = false;
                }, 1200);
            }

            loadSection(index) {
                const section = SECTIONS[index];
                const cardStage = document.getElementById('card-stage');

                // FADE OUT CURRENT CARDS with GSAP
                const currentCards = cardStage.querySelectorAll('.morph-card');

                if (currentCards.length > 0) {
                    // Enhanced exit animation with visualizer sync
                    const quantumLayers = document.getElementById('quantum-layers');

                    gsap.to(currentCards, {
                        opacity: 0,
                        scale: 0.9,
                        rotateY: 20,
                        z: -100,
                        duration: 0.5,
                        ease: "power2.in",
                        stagger: 0.06
                    });

                    // Subtle visualizer pulse on transition
                    gsap.to(quantumLayers, {
                        opacity: 0.6,
                        duration: 0.3,
                        ease: "power2.in",
                        onComplete: () => {
                            gsap.to(quantumLayers, {
                                opacity: 1,
                                duration: 0.5,
                                ease: "power2.out"
                            });
                        }
                    });
                }

                setTimeout(() => {
                    // CONFIGURE CARD STAGE FOR SPLITTING
                    cardStage.className = 'card-stage';
                    if (section.cards && section.cards.count > 1) {
                        cardStage.classList.add(`split-${section.cards.count}`);
                    }

                    // CREATE CARDS
                    cardStage.innerHTML = '';
                    const cardCount = section.cards?.count || 1;

                    for (let i = 0; i < cardCount; i++) {
                        const card = document.createElement('div');
                        card.className = 'morph-card' + (i > 0 ? ' card-clone' : '');

                        // DEPTH LAYER for parallax
                        const depthLayer = document.createElement('div');
                        depthLayer.className = 'card-depth-layer';
                        card.appendChild(depthLayer);

                        // CARD BACKGROUND ACCENT
                        const accent = document.createElement('div');
                        accent.className = 'card-bg-accent';
                        card.appendChild(accent);

                        // CARD CONTENT WRAPPER for fluid transitions
                        const contentWrapper = document.createElement('div');
                        contentWrapper.className = 'card-content-wrapper';
                        contentWrapper.style.cssText = 'position: relative; z-index: 1;';

                        if (section.cards && section.cards.contents && section.cards.contents[i]) {
                            contentWrapper.innerHTML = section.cards.contents[i];
                        } else {
                            contentWrapper.innerHTML = section.content;
                        }
                        card.appendChild(contentWrapper);

                        // APPLY CARD STYLES
                        if (section.cardStyle) {
                            Object.entries(section.cardStyle).forEach(([key, value]) => {
                                card.style.setProperty(key, value);
                            });
                        }

                        cardStage.appendChild(card);
                    }

                    // GSAP TIMELINE for sophisticated entrance choreography
                    const newCards = cardStage.querySelectorAll('.morph-card');
                    const tl = gsap.timeline();

                    // Animate cards with stagger
                    tl.fromTo(newCards,
                        {
                            opacity: 0,
                            scale: 0.85,
                            rotateY: -25,
                            rotateX: 15,
                            z: -200
                        },
                        {
                            opacity: 1,
                            scale: 1,
                            rotateY: 0,
                            rotateX: 0,
                            z: 0,
                            duration: 1.2,
                            ease: "power4.out",
                            stagger: {
                                amount: 0.3,
                                from: "start"
                            },
                            onComplete: () => {
                                newCards.forEach(card => card.classList.add('active'));
                            }
                        }
                    );

                    // Animate content within each card with fluid choreography
                    newCards.forEach((card, i) => {
                        const contentElements = card.querySelectorAll('h1, h2, .subtitle, .body-text, .stat-card');
                        tl.fromTo(contentElements,
                            {
                                opacity: 0,
                                y: 30,
                                scale: 0.95,
                                rotateX: -10
                            },
                            {
                                opacity: 1,
                                y: 0,
                                scale: 1,
                                rotateX: 0,
                                duration: 0.8,
                                ease: "power2.out",
                                stagger: 0.08
                            },
                            `-=${1.0 - (i * 0.1)}`  // Overlap with card animation
                        );

                        // Add prismatic shimmer to accent/highlight text
                        const accentText = card.querySelectorAll('.accent, .highlight');
                        tl.to(accentText, {
                            textShadow: '0 0 20px rgba(0, 255, 255, 0.8), 0 0 40px rgba(255, 0, 255, 0.6)',
                            duration: 0.6,
                            ease: "sine.inOut",
                            stagger: 0.1,
                            yoyo: true,
                            repeat: 1
                        }, `-=0.4`);
                    });

                    // Sync visualizer enhancement
                    const quantumLayers = document.getElementById('quantum-layers');
                    tl.to(quantumLayers, {
                        className: 'quantum-layers enhanced',
                        duration: 0.8,
                        ease: "power2.out"
                    }, `-=1.2`);

                    tl.to(quantumLayers, {
                        className: 'quantum-layers',
                        duration: 0.6,
                        ease: "power2.in"
                    }, `+=0.5`);
                }, 450);

                // Store reference to first card for backwards compatibility
                setTimeout(() => {
                    this.morphCard = cardStage.querySelector('.morph-card');
                    this.sectionContent = this.morphCard?.querySelector('div:last-child');
                }, 350);
            }

            jumpToSection(index) {
                if (index === this.currentSection || this.isTransitioning) return;
                this.currentSection = index;
                this.currentTick = 0;
                this.transitionToSection(index);
            }

            updateDebug() {
                document.getElementById('debug-section').textContent = this.currentSection;
                document.getElementById('debug-ticks').textContent = `${this.currentTick} / ${this.ticksPerSection}`;

                if (window.quantumVisualizers && window.quantumVisualizers[0]) {
                    const viz = window.quantumVisualizers[0];
                    document.getElementById('debug-offset').textContent = viz.params.offsetY.toFixed(2);
                    document.getElementById('debug-density').textContent = viz.params.gridDensity.toFixed(1);
                    document.getElementById('debug-rot').textContent = viz.params.rot4dXW.toFixed(2);
                }
            }
        }

        // ========== INITIALIZATION ==========
        document.addEventListener('DOMContentLoaded', () => {
            const layers = [
                { id: 'quantum-background', role: 'background', reactivity: 0.4 },
                { id: 'quantum-shadow', role: 'shadow', reactivity: 0.6 },
                { id: 'quantum-content', role: 'content', reactivity: 1.0 },
                { id: 'quantum-highlight', role: 'highlight', reactivity: 1.3 },
                { id: 'quantum-accent', role: 'accent', reactivity: 1.6 }
            ];

            window.quantumVisualizers = layers.map(layer => {
                const viz = new QuantumVisualizer(layer.id, layer.role, layer.reactivity);
                console.log(`âœ… ${layer.role} visualizer created`);
                return viz;
            }).filter(viz => viz.gl);

            function renderLoop() {
                window.quantumVisualizers.forEach(viz => viz.render());
                requestAnimationFrame(renderLoop);
            }
            renderLoop();

            window.scrollController = new ScrollController();

            console.log('ðŸš€ MINOOTS Experience Ready');
        });
    </script>
</body>
</html>

<!--
ðŸŒŸ A Paul Phillips Manifestation
Paul@clearseassolutions.com | Parserator.com
Â© 2025 Clear Seas Solutions LLC
-->
